---
title: "Matrix Federation API"
abbrev: "Matrix Federation API"
category: info

docname: draft-ralston-mimi-matrix-federation-latest
submissiontype: IETF  # also: "independent", "IAB", or "IRTF"
number:
date:
consensus: true
v: 3
area: "Applications and Real-Time"
workgroup: "More Instant Messaging Interoperability"
keyword:
 - matrix
 - mimi
 - federation
venue:
  group: "More Instant Messaging Interoperability"
  type: "Working Group"
  mail: "mimi@ietf.org"
  arch: "https://mailarchive.ietf.org/arch/browse/mimi/"
  github: "turt2live/ietf-mimi-matrix-federation"
  latest: "https://turt2live.github.io/ietf-mimi-matrix-federation/draft-ralston-mimi-matrix-federation.html"

author:
 -
    fullname: Travis Ralston
    organization: The Matrix.org Foundation C.I.C.
    email: travisr@matrix.org

normative:

informative:


--- abstract

The Matrix Federation API is the protocol by which servers communicate with each other,
independent of transport considerations and feature-specific details.


--- middle

# Introduction

Matrix is an open standard to provide secure, decentralized, communication for a variety of
use-cases, including Instant Messaging (IM), Voice over IP (VoIP) signaling, and Internet of
Things (IoT). While this feature set is diverse, the federation API is both transport-agnostic
and feature-agnostic: it works independently of the features being used or any protocols built
atop it.

This document covers the Federation API protocol only: other documents in this series cover areas
such as transport, collections of algorithms (room versions - described below), and event schema.


# Conventions and Definitions

{::boilerplate bcp14-tagged}

The following terms are used in this document:

**Homeserver**: The system which exposes and uses this Federation API, often containing a set
of users which can interact with it over a "Client-Server API", and has a server name to identify
it. A homeserver may also simply be referred to as a "server".

**User**: An account on a homeserver, capable of interacting with the homeserver and receiving
information within rooms. Users can have multiple devices as well.

**Device**: An identified session for a user to engage in end-to-end encryption with.

**Room**: Where events get sent and received. Rooms are not limited to instant messaging: they can
also be used for machine-to-machine communication, IoT, signaling, and more.

**Room version**: A specification for the algorithms which govern the room's behaviour. For example,
what is required for a valid event, redaction/deletion requirements, signing and security algorithms,
and other aspects as needed. It is not the number of times a room has been "upgraded".

**Event**: Information contained in a JSON structure for representation by other members of the room.
For example, a text message, image, or signaling data.

**State event**: A replaceable key/value pair visible to all members of the room. Often used as control
values for membership, power levels (permissions), and aesthetics like the room name and topic.

**Persisted Data Unit (PDU)**: Events which are formatted and appropriately annotated with information
needed to validate them over the Federation API/Transport. Normally persisted by homeservers and sent to
users.

**Ephemeral Data Unit (EDU)**: Non-critical information pushed between homeservers. EDUs are not expected
to be persisted and can be safely discarded by a homeserver.

**Transactions**: A container for PDUs and EDUs, sent between homeservers.

**Participating homeserver**: Servers which have users that are considered "joined" to the room. Membership
is defined by the algorithms in the room version.

# Communication Model

Rooms are where events get sent and are not "owned" by any particular entity or homeserver. Instead, the
room is fully replicated to other participating homeservers. Whether homeservers store that entire history 
or the bare minimum to maintain participation is left as an implementation detail. This allows a room to
be usable by any of the participating servers, even if one or all other servers are unreachable.

To achieve this, servers operate in a full-mesh, but fault-tolerant, federation: when a server wants to
send a PDU, it sends a transaction to all other participating homeservers. If any of those servers are
offline or unable to be reached then the transaction is retried some time later (however the transport
defines that).

Remote Procedure Calls (RPCs) are used to communicate with another server. The transport and format of
these calls are details left to another document.

# Transactions

At it's core, Matrix uses "transactions" to replicate PDUs and EDUs to other servers. Transactions MUST
NOT exceed 50 PDUs or 100 EDUs in order to reduce the risk of "entity too large"-style errors on the
receiving server's side. 

Servers SHOULD only send transactions for PDUs generated by their users, however when responding to 
backfill or other similar requests it is possible for a transaction to contain another server's PDUs.
EDUs from other servers MUST NOT appear in transactions.

# PDUs

The format of a PDU varies depending on the transport and room version at play. All PDUs represent a single
event from a room, however. Additional values, maximum sizes, etc are not defined in this document and
are instead described by the transport and room version documents applicable to the implementation.

# EDUs

EDUs are used to transmit information which does not need persistence by the server. While unused by this
document, other documents can use EDUs to transport ephemeral data such as read receipts, typing 
notifications, user presence, device list changes, and to-device messages (for sharing encryption keys
without persisting them into the room itself).

# Rooms and Room Versions

As described earlier by this document, rooms are where events are kept for view by the users within. These
events are then replicated

# Security Considerations

TODO Security


# IANA Considerations

This document has no IANA actions.


--- back

# Acknowledgments
{:numbered="false"}

TODO acknowledge.
